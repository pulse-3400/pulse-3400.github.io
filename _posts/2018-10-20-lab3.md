---
priority: 0.6
title: Lab 3
excerpt: Analog Circuitry and FFT
categories: labs
background-image: lab2-cover.png

---

### Radio Subteam
We began by hooking up two radios to two Arduinos using jumpers, since we did not have the premade boards available, nor the time to make a temporary breakout board. We tried using the “Getting Started” code provided on the class Github page just to test the basic functionality of the radios, changing their addresses as necessary based on the instructions in the lab. After some tweaking, we were able to achieve successful transmission relatively consistently. We found that reducing the transmission size increased the reliability substantially. At the default 32-byte size, close to 30% of packets were dropped, but at two bytes we did not have any failed transmissions during our testing period. This meant that we had an even larger incentive to reduce our transmission size. At some point, the radios stopped working for no discernible reason, but we learned enough from this test and from studying the provided code to start to integrate them into our design.

We considered was how we might be able to efficiently package the data we send over the radio. Our first consideration was our position in the maze.The final maze will be nine by nine squares, and our first idea was to use four bits for each axis, or eight bits total to represent our position in the grid, which would work up to a 16 by 16 grid. Having a separate variable for each axis means that we need an extra bit (a nine by nine maze has only 81 possible positions, meaning that we could conceivably represent all positions with seven bits instead of eight), but will make calculations on the robot much simpler. If we were to just directly enumerate the squares, we would probably need to do a table lookup each time we moved, rather than simply incrementing or decrementing a coordinate. We were not short on space for the transmission, but the alternative scheme remains an option should we need it for some reason.

The next consideration was for wall positions. The simplest method seemed to be allocating four bits for this, one for each of the possible four walls adjacent to a square in the maze. The bits would correspond to the North, East, South, and West walls, respectively.

Our final consideration, though not necessary for this lab, is treasure locations. We are not yet sure of how exactly the treasures must be identified in the GUI, but we estimate we must allocate at most five bits: two to tell which of the four faces of the square it is on, two for differentiating the three shapes, and one for indicating the color, red or blue. If we do not need to determine which wall face the treasure is on and only the square where it is located, then we could accomplish this with only three bits, which would bring our total transmission size below 16 bits. This means that our transmission could possibly be the size of a short.

<p align="center">
  <img src="/images/lab3_bitpack.PNG"/><br/>
        <i>Proposed Transmission Format (Size of Short).</i>
</p>

Given this proposed transmission format, the next step was to modify the robot software to actually find these values. With the addition of a right and left facing wall sensor, we had most of the hardware necessary, but additional software features would be required. We will discuss this in greater detail in the integration section.

### Robot/GUI Subteam
#### Robot
#### GUI
### Integration
The previous version of the robot’s code, while robust enough to navigate simple maze structures and follow lines, did not actually have any concept of its location or orientation; all of the decisions made were from current sensor information. That implementation already used a state machine (now more streamlined) to do its path following and wall avoidance, so our first task was to enhance the robots ability to track its own state using this existing infrastructure. 

The first addition made was a variable used to track the robot’s orientation, or which direction it is currently facing. This is done using an integer, which is initially set to a value in the low thousands. In order to determine our orientation, we do a modulus operation on this integer value where a result of 0 indicates we are facing North, 1 is East, 2 is South, and 3 is West. This implementation was chosen because it is so easily integrated with the existing state machine: upon completing a right turn, we increment the orientation variable by 1, and we decrement it on completing left turn.

Next, we needed the ability to track our position. Using the orientation variable, this was a relatively simple task: using a switch statement, we can check which direction we are facing, and upon moving forward we simply increment or decrement the correct position index. These position indices are currently set to zero initially and are global variables.

Determining wall positions is only a moderate logical challenge with the other features in place. We can check all three of our wall sensors as necessary, where the forward facing sensor will indicate a wall in the direction we are oriented towards, the left sensor the wall one position variable less, and the right sensor one position variable more. The way this is actually implemented involves checking how we are oriented, and then essentially assigning each sensor to toggle the appropriate wall bit for that orientation. Finally, upon starting we assume there is a wall directly behind the robot, and that it is facing due East.

The Arduino has a limited number of analog input pins, so integrating all of the features together (three line sensors, three wall sensors, and two amplifiers) required adding an analog multiplexer and the relevant control signals to the code.

