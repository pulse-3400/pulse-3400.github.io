---
priority: 0.6
title: Milestone 3
excerpt: Maze Traversing 
categories: milestones
background-image: lab1-cover.png

---

### Objective
The purpose of this milestone was to create improve our robot's right-hand wall following algorithm to some sort of an algorithm that allows it to more effciently and quickly explore a maze. By the completion of this milestone, our robot explored a maze by prioriting intersections that it hadn't visited before, and visiting those intersections. However, we have written a DFS algorithm (that we are currently implementing on our robot) and will document its progress here.

### Design
After deciding that we wanted to implement a DFS algorithm for our robot, we broke down the creation of the algorithm into intermediate steps to ensure that our robot would have some sort of working, optimized algorithm in the following order:

1) Turn-by-turn with wall avoidance (completed)

2) Turn-by-turn with wall avoidance and priority on unvisited neighboring locations (completed)

3) Priority on unvisited neighbors, wall avoidance, and path planning (work in progress)

Each of our newer algorithms built off of the previous.

### Implementation
We broke down the creation of our algorithm(s) into two steps: 1) writing an improved maze exploration algorithm and 2) testing the algorithm on our robot and updating the maze map GUI on the base station.

*Note: our latest software works such that our robot can only check for walls and make decisions about movement at an intersection. All of our maze-solving algorithms were written with this understanding.*

#### Maze Exploration

**1) First Algorithm: Turn-By-Turn with Wall Avoidance**

Similar to our right-hand wall following algorithm (from Lab 3) is a maze traversal with wall avoidance. With this algorithm, the robot moves forward at every intersection until it sees a wall in front of it. It then checks for a wall to the left of itself (turns left if there is none), then to the right of itself (turns right if there is none). If it detects a wall in front of, to the left of, and to the right of itself, the robot turns around 180 degrees.

Example:

Pros: A start to our second maze algorithm.

Cons: Can get stuck in many maze configurations--i.e. doesn't map the entire maze.


**2) Second Algorithm: Turn-By-Turn with Wall Avoidance and Priority on Unvisited Neighbors** 

This algorithm uses our previous one, but it puts proritizes unvisited neighboring intersections. That is, our robot is able to analyze the walls to the front and side of itself, and travel first to intersections that haven't been previously visited.

To check whether neighboring intersections have been visited or not, we implemented a simple 2D array of ints as our data structure, and kept track of data in the following way:

```
// ==== Maze Array Explanation ====
//
//   Array stores each integer value 
//   as follows:
//
//                       N E S W
//   [ 0 0 0 |    0    | 0 0 0 0 ] 
//             Visited    Walls
// ================================
/*
xpos = 0, ypos = 0 is the top left hand corner of the maze. The robot assumes it starts at (0, 0). X increases
left to right and Y increases top to bottom. When we visit an intersection, we set the visited bit to 1. We set wall bits as appropriate.*/
```

Our logic is fairly simple. When at an intersection, we first check for walls using bits 0 through 3 in our ```maze[][]``` array. We then check whether the adjacent squares have been visited by checking the visited bit (bit 4). We achieve such by bit shifting and bitwise operations:

```
//Wall values assignment
byte WP, L, B, R;
  L = (wallvalleft > WALLTHRESHOLD) ? B01 : 0;
  B = (wallval > WALLTHRESHOLD) ? B01 : 0;
  R = (wallvalright > WALLTHRESHOLD + 30) ? B01 : 0;
  WP = (L<<2) | (B<<1) | R ;
  
 //Assign walls for maze update and transmission
 switch(orientation % 4){
        case 0:
          walls = (B << 3) | (R << 2) | L ; // 1 1 0 1
          break;
        case 1:
          walls = (L << 3) | (B << 2) | (R << 1) ; // 1 1 1 0
          break;
        case 2:
          walls = (L << 2) | (B << 1) | R ; // 0 1 1 1
          break;
        case 3:
          walls = (R << 3) | (L << 1) | B ; // 1 0 1 1
          break;
      }
      
  //Check whether adjacent squares are visited
  switch(orientation % 4){
        case 0:
          L = (xpos > 0) ? maze[xpos - 1][ypos] & (1 << 4) : 0;
          B = (ypos > 0) ? maze[xpos][ypos - 1] & (1 << 4) : 0;
          R = (xpos < 8) ? maze[xpos + 1][ypos] & (1 << 4) : 0;
          break;
        case 1:
          L = (ypos > 0) ? maze[xpos][ypos - 1] & (1 << 4) : 0;
          B = (xpos < 8) ? maze[xpos + 1][ypos] & (1 << 4) : 0;
          R = (ypos < 8) ? maze[xpos][ypos + 1] & (1 << 4) : 0;
          break;
        case 2:
          L = (xpos < 8) ? maze[xpos + 1][ypos] & (1 << 4) : 0;
          B = (ypos < 8) ? maze[xpos][ypos + 1] & (1 << 4) : 0;
          R = (xpos > 0) ? maze[xpos - 1][ypos] & (1 << 4) : 0;
          break;
        case 3:
          L = (ypos < 8) ? maze[xpos][ypos + 1] & (1 << 4) : 0;
          B = (xpos > 0) ? maze[xpos - 1][ypos] & (1 << 4) : 0;
          R = (ypos > 0) ? maze[xpos][ypos - 1] & (1 << 4) : 0;
          break;
      }
```

We then use the L, B, and R variables to have our robot go in the direction of the neighbor it hasn't visited, or by default prioritize going forwards, left (second priority), right (third priority), or turn around 180 degrees (last priority).

Example:

<p align="center">
  <img src="/images/milestone3_unvisitedneighbors.gif" width="550px" height="397px"/><br/>
</p>

Pros: Allows the robot to explore more of the maze, data structure that doesn't use up too much memory, fairly easy implementation.

Cons: Cannot fully explore every maze configuration, not extremely efficient for solving an entire maze.

**3) Third Algorithm: Priority on Unvisited Neighbors, Wall Avoidance, and Path Planning (work in progress)**

Our algorithm doesn't take advantage of the fact that we keep track of *all* intersections in the maze--and whether we have visited them or not--with our current data structure. Although we have written an improved alogrithm, integrating it into our robot has proved more challenging than we thought. To see our current progress on this, read our "Path Planning Algorithm" section below.

#### Testing on Robot and Updating the GUI
We tested our algorithms on various maze sizes and wall orientations:

**1) 5x4 maze: **

**2) **

Our robot was also able to transmit maze information to our GUI:

### Path Planning Algorithm (In Progress)
We began by writing a [DFS algorithm in Java](https://github.com/pulse-3400/labs/blob/master/milestone3/Maze.java), since the language is similar to C++ and allows for easy implementation of various data structures. Although we didn't use this exact algorithm in our robot (took up a lot of memory, and difficult integration into our robot's code because of wall avoidance), it allowed us to understand how a depth-first search worked and gave us an idea for a better path planning algorithm for our robot.

Our current path planning algorithm keeps our ```int maze[][]``` data structure, and uses another integer array (vector) that essentially keeps a breadcrumb trail of the robot's traveled path. It is written such that when the robot reaches a "dead end," it knows a path to the closest location on the maze to an unvisited location. The idea is this:

```
* Our robot will travel by wall avoiding and going to unvisited neighbors when it reaches an intersection (our second algorithm, more detailed description above).
* At every intersection where there are two or more unvisited neighbors, our robot will clear our int array of locations and place this new location into the array. As it continues to travel, subsequent intersections with only one unvisited neighbor will be added in the int array, allowing the robot to remember a path to the closest location with an unvisited neighbor.
* When an intersection is reached such that all neighboring intersections have been visited and/or blocked by walls, the robot will backtrack to the closest location of an unvisited location by traversing through the int array.
```


### Modifications
One of the main objectives of the competition is having our robot travel through as much of the maze as possible. Although it was not slow, we initially thought that focusing on improving the speed of our robot rather than creating a complex searching algorithm might give our robot a better chance of mapping more of the maze. However, we quickly realized that increasing the speed was going to be more difficult than we thought--which delayed our progress on integrating an improved maze algorithm. You can read more about this [here](https://pulse-3400.github.io/aboutus/whatwedo.html).

